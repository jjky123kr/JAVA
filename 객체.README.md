# 객체지향 프로그램 
### 부품 객체를 먼저 만들고 이것들을 하나씩 조립해 완성된 프로그램 기법
#  객체
### 필드(속성) 과 메소드(동작)로 구성된 자바 객체로 모델링 가능
# 객체 지향 프로그래밍의 특징 
## 1. 캡슐화
 * 1).객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것
 * 2)외부 객체는 객체 내부 구조를 알지 못하며 객체가 노출해 제공하는 필드와 메소드만 이용 가능
 * 3)필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 
 * 4)자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지 결정하기 위해 접근 제한자(Access Modifier) 사용
## 2. 상속 
* 1)상위(부모) 객체의 필드와 메소드를 하위(자식) 객체에게 물려주는 행위
* 2)하위 객체는 상위 객체를 확장해서 추가적인 필드와 메소드를 가질 수 있음
* 3)상속은 (필드, 메소드)
* 4)유지보수 편리함
* 5)반복된 코드의 중복을 줄임
* 6)생성자는 상속이 되지 않는다. 
##  3. 다형성
* 1)같은 타입이지만 실행 결과가 다양한 객체를 대입할 수 있는 성질
* 2)부모 타입에는 모든 자식 객체가 대입
* 3)인터페이스 타입에는 모든 구현 객체가 대입
## 3.효과
* 1)객체를 부품화시키는 것 가능
* 2)유지보수 용이

### 객체 와 클래스
* 현실세계: 설계도-> 객첵
*     자바: 클래스 -> 객체 

### 클래스 이름
* 자바 식별자 작성 규칙
* 하나 이상의 문자로 이루어져야 한다.
* 첫 번째 글자는 숫자가 올 수 없다.
* 특수 문자는 사용할 수 없다. 
* 자바 키워드는 사용할 수 없다. 
* 첫 글자와 연결된 다른 단어의 첫 글자는 대문다
### 클래스 선언
* 알파벳 대소문자는 서로 다른 문자로 인식 (대소문자 주의)
* 소스 파이리당 하나의 클래스를 선언하는 것이 관례
* 두개이상의 클래스도 선언 가능
* 소스 파일 이름과 동일한 클래스만 public으로 선언
* 메소드이름과 클래스 명과 동일 해야 한다. 

### new 클래스 
* 클래스는 생성자를 호출하는 코드
* 생성된 객체는 힙 메모리 영역에 생성 
* new 연산자는 객체를 생성 후 객체  생성 리턴

#### 클래스의 구성
* 필드 ,생성자, 메소드 
* 필드는 객체의 데이터가 저장되는 곳
* 생성자는 객체 생성시 초기와 역할   
* 메소드 객체의 동작에 해당하는 실행 블록


##### 사용자 정의 클래스(자료형) 
      변수, 생성자, 메소드 작성
### 변수 
멤버변수 :메소드 바깥쪽에 정의되는 변수
### 생성자
* 생성자는 클래스명과 동일한 이름으로 생성해야한다.
* 매개 변수가 없는 생성자: 기본 생성자(Default Constructor) 
* 기본 생성자(필드와 생성자 구성)독립적으로 실행이 되지 않는다
* 생성자의 역할은 필드값을 초기값 생성한다 
* 기본 생성자는 객체를 생성될때 컴파일러가 자동으로  생성해준다.
* 생성자는 객체가 생성될 때 호출된다.
ex) Animal   an  = new  Animal();
                     생성자 호출       

### 메소드 
* 값을 돌려준다.
* 필드 값을 출력하는 역할
* 


``````````````

public class Animal {
    int age;  //멤버변수,필드(field),전역변수 : heap힙 메모리에 저장(자동 초기값0;값)
          // : 메소드 바깥쪽에 정의되는 변수
   public Animal(){  //기본 생성자(Default constructor) //클래스명과 동일
	                   
   System.out.println("생성자 호출 성공");        // 생성자 호출이 없을때  자동으로 컴파일러 한다.
	}
    public static void main(String[] args) {
	// TODO Auto-generated method stub
       
   int a=10;   // 지역변수: stack 메모리 영역에 저장
		
   String str = new String("자바");
		
  Animal  a1 =       new    Animal();
  클래스  레퍼런스 변수  연산자  생성자 호출
		
	System.out.println();         // 오류
	System.out.println(a1.age);   //0    *a1이 갖고 있는 주소 참조해서 (.)점으로 접근한다. 

	a1.age=5;
	System.out.println(a1.age);   //5
	
    Animal   a2   = new  Animal();
       System.out.println(a2.age);
	                   주소값
	    
	    
    if(a1==a2) {                    //주소값 비교
	   System.out.println("같은주소");
    }else {
	   System.out.println("다른 주소");
	    }
	}

}


````````````
``````````````
package p2022_06_28;

//p201 //접근제어자는 1번만 쓴다. 메인 메소드만 사용할수 있다. 
class Car{
	//필드 (field)=속성을 표현한다. 주어진 값으로 초기값이 된다. 
	String company ="현대 자동차";
	String model="그랜저";
	String color ="검정";
	int maxSpeed=350;          
	int Speed;             //int는 자동으로 초기값0;

	
	public Car() {            //기본 생성자(필드와 생성자 구성)독립적으로 실행이 되지 않는다
        System.out.println("생성자 호출");
	}            
}
public class CarEX {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
        // 객체 생성
		Car mycar = new Car(); //객체를 생성할때 생성자가 호출된다. 
		System.out.println("제작회사:"+mycar.company);
		System.out.println("모델명:"+mycar.model);
		System.out.println("색깔:"+mycar.color);
		System.out.println("최고속도:"+mycar.maxSpeed);
		System.out.println("현재속도:"+mycar.Speed);  //0
		
		//필드값 변경
		mycar.Speed=60;
		System.out.println("수정된 속도:"+mycar.Speed);//60
		
		
	}
}

````````````````
````````````````
package p2022_06_28;

//p202   멤버변수  
class FieldInitValue{
//	   필드(field)
	byte byteField;
	short shortField;
	int intField;                   //정수형0 초기화  *
	long longField;
	
	float floatField;               //실수형 0.0 초기화 *   
	double doubleField;
	
	char charField;
	boolean booleanField;           //논리형 false로 초기화*
	
	int[] arrField;
	String  referenceField;         //null은 참조할 주소가 없다. *
			                        //null 로 초기화
}

public class FieldEx {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		 FieldInitValue f = new FieldInitValue();
		 
		 System.out.println("byteField:"+f.byteField);
		 System.out.println("shortField:"+f.shortField);
		 System.out.println("intField:"+f.intField);
		 System.out.println("longField:"+f.longField);
		 
		 
		 System.out.println("floatField:"+f.floatField);
		 System.out.println("doubleField:"+f. doubleField);
		 
		 System.out.println("charField :"+f.charField);
		 System.out.println("booleanField :"+f.booleanField);
		 
		 
		 System.out.println("arrField:"+f.arrField);
		 System.out.println("referenceField:"+f.referenceField);
	}

}













